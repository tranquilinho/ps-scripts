#!/bin/bash

readonly info="    "
readonly warning="WARN"
readonly critical="CRIT"
readonly success=" OK "

readonly log_hostname=$(hostname)
readonly log_format='${log_timestamp} ${log_hostname} "$(printf "%20s" ${log_facility})"'

# warning: appending logalize alters the value of $?, so you must use
# ${PIPESTATUS[0]} instead
logalize(){
	local logalize_file=$1
	cat - | while read line_to_log ; do
	    echo "${line_to_log}"
	    printf -v log_timestamp "%(%s %Y-%m-%d %H:%M:%S)T" -1
	    log_prefix=$(eval echo ${log_format})
	    printf "%s %s %s\n" "${log_prefix}" "${info}" "${line_to_log}"  >> ${logalize_file}
	done
}


log(){
    [ -z "${log_file}" ] && readonly log_file=${log_dir}/build.log
    [ -z "${log_facility}" ] && readonly log_facility=${service}-build
    [ ! -d $(dirname ${log_file}) ] && mkdir -p $(dirname ${log_file})
    printf -v log_timestamp "%(%s %Y-%m-%d %H:%M:%S)T" -1
    echo "$(eval echo "${log_format}") $1" >> ${log_file}
}


download_pkg(){
    wget -c ${url}
    if [ $? -ne 0 ]; then
	log "${critical} Could not download package"
	exit 3
    fi
}

verify_pkg(){
    pkg_hash=$( ${hasher} ${pkg} | cut -d " " -f 1 )
    if [ ${pkg_hash} != ${expected_hash} ]; then
	log "${critical} Package integrity test failed (${pkg_hash})"
	exit 4
    fi
}

common_build_vars(){
    [ -z "${pkg_name}" -o -z "${pkg_version}" ] && echo Package name undefined && exit 4
    [ -z "${pkg_dir}" ] && readonly pkg_dir=${pkg_name}-${pkg_version}
    [ -z "${pkg}" ] && readonly pkg=${pkg_dir}.tar.gz
    [ -z "${prefix}" ] && readonly prefix=${usr_prefix}/${pkg_dir}
    [ -z "${hasher}" ] && readonly hasher=sha1sum
    [ -z "${url}" ] && readonly url=${url_base}/${pkg}
}

build_preconditions(){
    [ -z "${build_dir}" ] && echo build_dir undefined && exit 6

    ${scripts_base}/check_build_env || exit 3

    [ -d ${build_dir} ] || mkdir -p ${build_dir}

    cd ${build_dir}

    common_build_vars 
    log "${info} preconditions start ${pkg_name}"

    download_pkg
    verify_pkg

    tar xfz ${pkg}
    cd ${pkg_dir}
    log "${success} preconditions finish ${pkg_name}"
}

# Params:
# $1 make option
# $2 (noinstall)
standard_install(){
    log "${info} standard install start ${pkg_name}"
    
    # make clean &&  
    make $1 -j 2 2>&1 | logalize $(make_log)
    if [ ${PIPESTATUS[0]} -ne 0 ]; then
	log "${critical} Problem building ${pkg_name}"
	exit 8
    fi
    if [ "a$2" != "anoinstall" ]; then
	make install 2>&1 | logalize $(make_log)
	if [ ${PIPESTATUS[0]} -ne 0 ]; then
	    log "${critical} Problem building ${pkg_name}"
	    exit 8
	fi
    fi

    if [ $? -ne 0 ]; then
	log "${critical} Problem installing ${pkg_name}"
	exit 8
    fi
    ln -s ${prefix} ${usr_prefix}/${pkg_name}
    log "${success} standard install finish ${pkg_name}"
}

install_prereq(){
    prereq=$1
    # by now, asume prereq is installed if both the directory and the symlink exist
    local installed=1
    link=${usr_prefix}/${prereq}
    if [ -s ${link} ];then
	ls  --dereference-command-line-symlink-to-dir ${link}
	[ $? -eq 0 ] && installed=0
    fi
    if [ ${installed} -ne 0 ]; then
	${scripts_base}/build/${prereq}
	if [ $? -ne 0 ]; then
	    log "${critical} Problem installing prereq ${prereq}"
	    [ "k$2" == "kmandatory" ] && exit 7
	fi
    else
	log "${warning} Prereq ${prereq} already installed"
    fi
}

check_params(){
    local parameters=$1
    local program=$2
    local spaces="${parameters//[^ ]/}"
    local number_of_parameters=$(( ${#spaces} + 1 ))
    shift
    shift
    if [ $# -ne ${number_of_parameters} ]; then
	echo "Wrong number of parameters parameter"
	echo "Syntax: ${program} ${parameters}"
	exit 2
    fi
}

# It expects "$@" as its 1st argument
parse_arguments(){
  if [ "$#" -gt 0 ]; then
    while getopts "u:k:b" options; do
      case "${options}" in
	b)
	  readonly hex_options="od -x -N 129"
	  ;;
	u)
	  readonly url="${OPTARG}"
	  ;;
	k)
	  readonly keyphrase="${OPTARG}"
	  ;;
        *)
          echo "Unknow option" 1>&2 
          print_usage
          ;;
       esac
     done
     shift $((OPTIND-1))
  else
      print_usage
  fi
}


watchdog(){
    local -r timeout=$1
    shift
    local -r delay=1
    local -r interval=1
    (
	$@ &
	pid=$!
	((t = timeout))

	while ((t > 0)); do
            sleep ${interval}
            kill -0 ${pid} || exit
            ((t -= interval))
	done

	kill -s SIGTERM ${pid} && kill -0 $$ || exit 1
	sleep ${delay}
	kill -s SIGKILL ${pid}
	exit 2
    ) 2> /dev/null &

}

daemon_stop(){
    local pid_file=$1
    if [ ! -f ${pid_file} ]; then
	log "${critical} PID file ${pid_file} missing"
	return 2
    fi
    local pid=$(cat ${pidfile})
    kill ${pid}
    local waited=0
    while [ -n "$(ps -o pid= -o comm= -p ${pid} )" ]; do
	waited=$(( waited + 1 ))
	if [ ${waited} -gt 15 ]; then
	    kill -9 ${pid}
	    break
	fi
	sleep 1
    done
}

is_running(){
    local process_name=$1
    local process_count=$(ps h -C ${process_name} | wc -l)
    if [ ${process_count} -gt 0 ]; then
	return 0
    else
	return 1
    fi
}

configure_log(){
    [ -z "${install_log_dir}" ] && local install_log_dir=${log_dir}/install
    [ ! -d ${install_log_dir} ] && mkdir ${install_log_dir}
    echo ${install_log_dir}/${pkg_name}_configure.log
}

make_log(){
    [ -z "${install_log_dir}" ] && local install_log_dir=${log_dir}/install
    [ ! -d ${install_log_dir} ] && mkdir ${install_log_dir}
    echo ${install_log_dir}/${pkg_name}_make.log
}